# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_pathway.ipynb.

# %% auto 0
__all__ = ['get_reactome_raw', 'get_reactome', 'query_reactome', 'add_react_ref', 'plot_path', 'plot_overlap']

# %% ../nbs/06_pathway.ipynb 3
# reactome, pip install reactome2py
from pandas import json_normalize
from reactome2py import analysis
from matplotlib import pyplot as plt
import numpy as np, pandas as pd
from .data import *

# %% ../nbs/06_pathway.ipynb 5
def get_reactome_raw(gene_list):
    "Reactome pathway analysis for a given gene set; returns raw output in dataframe."
    gene_str = ','.join(gene_list)
    # set page size and page to -1 ensures to display all pathway results, sort by pvalue instead of fdr, projection set to True is consistent with official web
    result = analysis.identifiers(gene_str, page_size='-1', page='-1', sort_by='ENTITIES_FDR',projection=True)
    return json_normalize(result['pathways'])

# %% ../nbs/06_pathway.ipynb 8
def get_reactome(gene_list,
                 p_type='FDR', # or p
                ):
    "Reactome pathway analysis for a given gene set; returns formated output in dataframe with additional -log10(p)"
    assert p_type in ['p','FDR']
    col='entities.pValue' if p_type=='p' else 'entities.fdr'
    print('Running pathway anlysis')
    out = get_reactome_raw(gene_list)
    print('Done')
    out = out[['name','stId',col]].rename(columns={col:p_type,'stId':'reactome_id'})
    out[f'-log10_{p_type}'] = -np.log10(out[p_type]).round(3)
    return out

# %% ../nbs/06_pathway.ipynb 16
def query_reactome(uniprot_id,
                   level='lowest', # or all
                  ):
    """Query uniprot ID in Reactome all level pathway database."""
    level = level.lower()
    assert level in ['all', 'lowest']
    ref = Data.get_reactome_pathway() if level =='all' else Data.get_reactome_pathway_lo() 

    # Filter specific uniprot
    uniprot_ref = ref[ref.uniprot == uniprot_id].copy()

    # Remove duplicates before grouping (optional: depends on whether one reactome_id can have duplicate types)
    uniprot_ref = uniprot_ref.drop_duplicates(subset=["reactome_id", "type"])

    # Group by reactome_id and aggregate other columns
    grouped = uniprot_ref.groupby("reactome_id", as_index=False).agg({
        "uniprot": "first",
        "pathway": "first",
        "type": lambda x: ", ".join(sorted(set(x))),
        "species": "first"
    })

    return grouped.reset_index(drop=True)

# %% ../nbs/06_pathway.ipynb 20
def add_react_ref(react_df,uniprot):
    path_all = query_reactome(uniprot,level='all')
    path_lowest = query_reactome(uniprot,level='lowest')
    react_df=react_df.copy()
    react_df[f'{uniprot}_path_all'] = react_df.reactome_id.isin(path_all.reactome_id).astype(int)
    react_df[f'{uniprot}_path_lowest'] = react_df.reactome_id.isin(path_lowest.reactome_id).astype(int)
    return react_df

# %% ../nbs/06_pathway.ipynb 24
def plot_path(react_df, # the output df of get_reactome
              p_type='FDR', 
              ref_id_list=None, # list of reactome_id
              ref_col = None, # column in reac_df, 1 or 0 to indicate whether it's in ref
              top_n=10, 
              max_label_length=80 ):
    """
    Plot the output of get_reactome.
    If ref_df is provided, bars corresponding to pathways in ref_df are shown in dark red.
    """
    assert p_type in ['p','FDR']
    p_col=f'-log10_{p_type}'
    # Take top_n rows
    subset = react_df.head(top_n)

    # Determine bar colors: if ref_df is provided, highlight matching pathways
    if ref_id_list is not None:
        ref_ids = set(ref_id_list)
        colors = ['darkred' if rid in ref_ids else 'C0' for rid in subset['reactome_id']]
    elif ref_col is not None:
        ref_ids = set(react_df[react_df[ref_col]==1].reactome_id)
        colors = ['darkred' if rid in ref_ids else 'C0' for rid in subset['reactome_id']]
    else:
        colors = 'C0'

    # Reverse order for horizontal bar plot
    data = subset.set_index('name')[p_col].iloc[::-1]
    # If colors is a list, reverse it to match the data order
    if isinstance(colors, list):
        colors = list(reversed(colors))

    # Truncate labels if too long
    truncated_labels = [label[:max_label_length] + '...' if len(label) > max_label_length else label for label in data.index]
    data.index = truncated_labels

    # Calculate figure width based on label length
    base_width = 2
    max_label = max(data.index, key=len)
    additional_width = len(max_label) * 0.1  # adjust scaling factor as needed
    figsize = (base_width + additional_width, 3 * top_n / 10)

    data.plot.barh(figsize=figsize, color=colors)
    plt.ylabel('')
    plt.xlabel(p_col.replace('_', '(', 1) + ')')
    plt.tight_layout()

# %% ../nbs/06_pathway.ipynb 31
def plot_overlap(react_df, 
                 ref_id_list=None,
                 ref_col = None, # column in reac_df, 1 or 0 to indicate whether it's in ref
                 p_type='FDR',
                 thr=0.05, # original threshold of p value, will be log10 transformed
                ):
    assert p_type in ['p','FDR']
    p_col=f'-log10_{p_type}'
    p_col_convert=p_col.replace('_', '(', 1) + ')' # e.g., use -log10(FDR) instead of -log10_FDR 

    if ref_id_list is not None:
        react_df[(react_df.reactome_id.isin(ref_id_list))][p_col].hist(bins=100)

    elif ref_col is not None:
        react_df[react_df[ref_col]==1][p_col].hist(bins=100)
    else:
        raise ValueError("Need to give values to ref_id_list or ref_col")
        
    threshold = -np.log10(thr)
    plt.axvline(x=threshold, color='red', linestyle='--', label='FDR = 0.05')
    plt.legend()
    
    plt.xlabel(p_col_convert)
    plt.title(f'Histogram of {p_col_convert}')
