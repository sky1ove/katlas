# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['Data', 'raw2norm', 'get_one_kinase', 'unstack', 'get_dict', 'paper_score_func', 'get_paper_score',
           'average_score_func', 'get_average_score']

# %% ../nbs/00_core.ipynb 2
import pandas as pd
import numpy as np
import seaborn as sns

from fastbook import *

# %% ../nbs/00_core.ipynb 5
class Data:
    """
    A class for fetching various datasets.
    """
    
    # Kinase info
    KINASE_INFO_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/STkinase_info.parquet"
    KINASE_ALL_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/full_kinase_info.parquet"
    
    # ESM
    KINASE_ESM_RAW_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/kinase_esm.parquet"
    KINASE_ESM_PCA_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/kinase_esm_pca32.parquet"
    KINASE_ESM_FULL_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/kinase_esm_full.parquet"
    
    # T5
    KINASE_T5_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/T5_xl_uniref50.parquet"
    KINASE_T5_FULL_BFD_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/T5_xl_bfd.parquet"
    KINASE_T5_FULL_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/T5_xl_uniref50_full.parquet"
    
    # Amino acid info
    AA_INFO_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/aa_info.parquet"
    AA_FEATURE_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/aa_rdkit.parquet"
    
    # Paper raw data
    RAW_KINASE_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/paper_raw.parquet"
    NORM_KINASE_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/paper_norm.parquet"
    SCALE_KINASE_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/paper_scale.parquet"

    # Unstacked target
    RAW_UNSTACK_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/unstack_raw.parquet"
    
    MEDIAN_UNSTACK_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/unstack_median.parquet"
    STANDARD_UNSTACK_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/unstack_standard.parquet"
    LOG_UNSTACK_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/unstack_log.parquet"
    
    Q85_UNSTACK_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/unstack_q85.parquet"
    Q85_UP40_UNSTACK_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/unstack_q85_up40.parquet"
    
    # Stacked target
    STANDARD_STACK_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/pivot_standard.parquet"
    LOG_STACK_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/pivot_log.parquet"
    
    # Prepared dataset
    DF_URL = "https://github.com/sky1ove/katlas/raw/main/dataset/df_esm64_aa16.parquet"
    
    def __init__(self):
        pass
    
    @staticmethod
    def _fetch_data(url):
        """
        Fetches the data from the given URL and returns a DataFrame
        """
        df = pd.read_parquet(url)
        if 'Unnamed: 0' in df.columns:
            df = df.rename(columns={'Unnamed: 0': 'kinase'})
        return df
    

    @staticmethod
    def get_stack_raw():
        return Data._fetch_data(Data.RAW_KINASE_URL)
    
    @staticmethod
    def get_stack_norm():
        return Data._fetch_data(Data.NORM_KINASE_URL)
    
    
    @staticmethod
    def get_stack_scale():
        return Data._fetch_data(Data.SCALE_KINASE_URL)

    @staticmethod
    def get_kinase_info():
        return Data._fetch_data(Data.KINASE_INFO_URL)

    @staticmethod
    def get_kinase_info_full():
        return Data._fetch_data(Data.KINASE_ALL_URL)
    
    @staticmethod
    def get_esm():
        return Data._fetch_data(Data.KINASE_ESM_RAW_URL)

    @staticmethod
    def get_esm_full():
        return Data._fetch_data(Data.KINASE_ESM_FULL_URL)

    @staticmethod
    def get_t5():
        return Data._fetch_data(Data.KINASE_T5_URL)

    @staticmethod
    def get_t5_full():
        return Data._fetch_data(Data.KINASE_T5_FULL_URL)
    
    @staticmethod
    def get_t5_bfd_full():
        return Data._fetch_data(Data.KINASE_T5_FULL_BFD_URL)
    

    @staticmethod
    def get_aa_info():
        return Data._fetch_data(Data.AA_INFO_URL)

    @staticmethod
    def get_aa_feature():
        return Data._fetch_data(Data.AA_FEATURE_URL)

    @staticmethod
    def get_unstack_standard():
        return Data._fetch_data(Data.STANDARD_UNSTACK_URL)

    @staticmethod
    def get_unstack_log():
        return Data._fetch_data(Data.LOG_UNSTACK_URL)

    @staticmethod
    def get_unstack_med():
        return Data._fetch_data(Data.MEDIAN_UNSTACK_URL)

    @staticmethod
    def get_unstack_raw():
        return Data._fetch_data(Data.RAW_UNSTACK_URL)

    @staticmethod
    def get_unstack_q85():
        return Data._fetch_data(Data.Q85_UNSTACK_URL)

    @staticmethod
    def get_unstack_q85_up40():
        return Data._fetch_data(Data.Q85_UP40_UNSTACK_URL)

    @staticmethod
    def get_log_stack():
        return Data._fetch_data(Data.LOG_STACK_URL)

    @staticmethod
    def get_standard_stack():
        return Data._fetch_data(Data.STANDARD_STACK_URL)

    @staticmethod
    def get_prepared_data():
        return Data._fetch_data(Data.DF_URL)
    

# %% ../nbs/00_core.ipynb 11
def raw2norm(df, #a single kinase's df that has position as index, and a.a. as columns
         PDHK=False, #whether this kinase belongs to PDHK family
        ):
    columns_to_exclude = ['S', 'T', 'C', 't', 'y']
    
    if PDHK:
        columns_to_exclude.append('Y')
        divisor = 16
    else:
        divisor = 17
    
    s = df.drop(columns=columns_to_exclude).sum(1)
    df2 = df.div(s, axis=0)
    df2.C = df2.C / (df2.C.median() * divisor)
    df2['S'] = df2.drop(columns=columns_to_exclude).median(1)
    df2['T'] = df2.drop(columns=columns_to_exclude).median(1)
    df2 = round(df2, 4)
    
    return df2

# %% ../nbs/00_core.ipynb 12
def get_one_kinase(df, #stacked dataframe (paper's raw data)
               kinase, # a specific kinase
               normalize=False, # normalize according to the paper; special for PDHK1/4
              ):
    "Obtain a specific kinase data from stacked dataframe, decide whether or not to normalize"
    
    p = pd.DataFrame(df.loc[kinase],columns = [kinase]).reset_index().rename(columns={'index':'substrate'})
    p['position'] = p.substrate.str.extract('(-?\d+)')
    p['aa'] = p.substrate.str[-1]
    p.position = p.position.astype(int)
    pp = p.pivot(index='position', columns='aa', values=kinase)
    if 's' in pp.columns:
        pp = pp.drop(columns=['s'])

    if normalize:
        pp = raw2norm(pp, PDHK=True if kinase == 'PDHK1' or kinase == 'PDHK4' else False)
    return pp

# %% ../nbs/00_core.ipynb 25
def unstack(df, name):
    # Unstack
    df = df.unstack().reset_index(name = name)
    
    # Rename column
    df = df.rename(columns = {'level_0':'substrate'})
    
    # Reorder column
    df = df[['kinase','substrate',name]]
    
    # Deal with some warning issue
    df = df.copy()
    
    # Divide substrate info into position and aa
    df['position'] = df.substrate.str.extract('(-?\d+)')
    df['aa'] = df.substrate.str[-1]
    
    # Remove 's' as it is a duplicate of 't'
    df = df[df['aa'] != 's'].reset_index(drop=True)
    
    return df

# %% ../nbs/00_core.ipynb 31
def get_dict(input_string):
    "Given a substrate string, returns a dictionary, and positions to be calculated"
    
    acceptor_position = input_string.find('*') - 1

    # Dictionary to store positions of amino acids
    aa_dict = {}

    columns = []
    # Loop through each character in the string and check if it's an alpha
    for i, char in enumerate(input_string):
        if char.isalpha():  # Check if the character is an alphabet (amino acid)
            pos = i - acceptor_position
            pos = pos if pos <= 0 else pos - 1  # Minus 1 if the position is positive
            aa_dict[pos] = char
            if -5 <= pos <= 4 and pos != 0:
                columns.append(f'{pos}{char}')

    return aa_dict,columns

# %% ../nbs/00_core.ipynb 38
def paper_score_func(r, columns):
    "Functions of calculating the kinase score given substrate string, according to the paper"
    
    divide = 16 if 'PDHK' in r.name else 17
    score_raw = r[columns].product() * divide ** len(columns)
    score_log = np.log2(score_raw)
    return score_raw, round(score_log,2)

# %% ../nbs/00_core.ipynb 39
def get_paper_score(df, # Reference df where kinase is index, position+substrate is column
                    input_string # Format of string should be sth like this "PSVEPPLs*QET"
                   ):
    
    "Given reference (stacked df) and input substrate string, calculate possibilities that kinase can bind, according to the paper"
    aa_dict,cols = get_dict(input_string)
    print(aa_dict)
    print(f'calculated columns: {cols}')
    func = partial(paper_score_func, columns=cols)
    out_df = pd.DataFrame(df.apply(func, axis=1,result_type='expand'))
    out_df.columns = ['raw_score','log2_score']
    # out_df = pd.DataFrame(norm.apply(func, axis=1),columns=['raw_score','log2(score)'])
    return out_df

# %% ../nbs/00_core.ipynb 49
def average_score_func(r, columns):
    "Functions of calculating the average score of each position"
    
    average = r[columns].sum()/len(columns)
    return average

# %% ../nbs/00_core.ipynb 50
def get_average_score(df,  # Reference df, where index is kinase, and columns is position+substrate
                      input_string, # string of substrate, following the format of "PSVEPPLs*QETFSDL"
                     ):
    
    "Given reference (stacked df) and input substrate string, calculate scores based on the average formula"

    
    aa_dict,cols = get_dict(input_string)
    print(aa_dict)
    print(f'calculated columns: {cols}')
    func = partial(average_score_func, columns=cols)
    out_df = pd.DataFrame(df.apply(func, axis=1,result_type='expand'))
    out_df.columns = ['average']
    # out_df = pd.DataFrame(norm.apply(func, axis=1),columns=['raw_score','log2(score)'])
    return out_df
