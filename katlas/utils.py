"""Functions to preprocess sequence to prepare kinase substrate dataset"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_utils.ipynb.

# %% auto 0
__all__ = ['get_fasta', 'aln2df', 'get_path', 'get_diff', 'check_seq', 'check_seqs', 'check_seq_df', 'validate_site',
           'validate_site_df', 'phosphorylate_seq', 'phosphorylate_seq_df', 'extract_site_seq', 'get_reactome_raw',
           'get_reactome', 'plot_path']

# %% ../nbs/01_utils.ipynb 3
import numpy as np, pandas as pd
from tqdm import tqdm
from .data import *
from fastcore.meta import delegates
from pathlib import Path

# reactome
from pandas import json_normalize
from reactome2py import analysis
from matplotlib import pyplot as plt

# fasta
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO, AlignIO

# %% ../nbs/01_utils.ipynb 8
def get_fasta(df,seq_col='kd_seq',id_col='kd_ID',path='out.fasta'):
    "Generate fasta file from sequences."
    records = [
        SeqRecord(Seq(row[seq_col]), id=row[id_col], description="")
        for _, row in df.iterrows()
    ]
    SeqIO.write(records, path, "fasta")
    print(len(records))

# %% ../nbs/01_utils.ipynb 10
def aln2df(fname):
    'Read .aln file from clustalo output into a dataframe'
    alignment = AlignIO.read(fname, "clustal")
    alignment_array = [list(str(record.seq)) for record in alignment]
    df = pd.DataFrame(alignment_array)
    df.columns = df.columns+1 # use amino acid index starting from 1
    return df

# %% ../nbs/01_utils.ipynb 12
def get_path(dir_path,fname):
    "Ensure the directory exists and return the full file path."
    dir_path = Path(dir_path).expanduser()
    dir_path.mkdir(parents=True,exist_ok=True)

    return dir_path/fname

# %% ../nbs/01_utils.ipynb 14
def get_diff(df1, df2, col1, col2=None):
    "Get non-overlap parts of two dataframes."
    if col2 is None:
        col2=col1
    df1_unique = df1[~df1[col1].isin(df2[col2])]
    df2_unique = df2[~df2[col2].isin(df1[col1])]
    return df1_unique, df2_unique

# %% ../nbs/01_utils.ipynb 20
def check_seq(seq):
    """Convert non-s/t/y characters to uppercase and replace disallowed characters with underscores."""
    acceptor = seq[len(seq) // 2]
    assert acceptor.lower() in {'s', 't', 'y'}, f"{seq} has {acceptor} at position {len(seq) // 2}; need to have one of 's', 't', or 'y' in the center"

    allowed_chars = set("PGACSTVILMFYWHKRQNDEsty")
    return "".join(char if char in {'s', 't', 'y'} else (char.upper() if char.upper() in allowed_chars else '_') for char in seq)

# %% ../nbs/01_utils.ipynb 23
def check_seqs(seqs:pd.Series):
    "Convert non-s/t/y to upper case & replace with underscore if the character is not in the allowed set"
    assert len(seqs.str.len().value_counts())==1, 'inconsistent sequence length detected'
    return seqs.apply(check_seq)

# %% ../nbs/01_utils.ipynb 24
def check_seq_df(df,col):
    "Convert non-s/t/y to upper case & replace with underscore if the character is not in the allowed set"
    assert len(df[col].str.len().value_counts())==1, 'inconsistent sequence length detected'
    return df[col].apply(check_seq)

# %% ../nbs/01_utils.ipynb 27
def validate_site(site_info,
                  seq):
    "Validate site position residue match with site residue."
    pos=int(site_info[1:])-1 # python index starts from zero
    if pos >= len(seq) or pos < 0: 
        return int(False)
    return int(seq[pos]==site_info[0])

# %% ../nbs/01_utils.ipynb 30
def validate_site_df(df, 
                     site_info_col,
                     protein_seq_col): 
    "Validate site position residue match with site residue in a dataframe."
    return df.apply(lambda r: validate_site(r[site_info_col],r[protein_seq_col]) , axis=1)

# %% ../nbs/01_utils.ipynb 33
def phosphorylate_seq(seq, # full protein sequence
                      *sites, # site info, e.g., S140
                      ):
    "Phosphorylate protein sequence based on phosphosites (e.g.,S140). "
    seq = list(seq)

    for site in sites:
        char = site[0] 
        position = int(site[1:]) - 1 # substract 1 as python index starts from 0

        if 0 <= position < len(seq):
            if seq[position] == char:
                seq[position] = char.lower()  
            else:
                raise ValueError(f"Mismatch at position {position+1}: expected {char}, found {seq[position]}")
        else:
            raise IndexError(f"Position {position+1} out of range for sequence length {len(seq)}")

    return ''.join(seq)

# %% ../nbs/01_utils.ipynb 35
def phosphorylate_seq_df(df,
                         id_col='substrate_uniprot', # column of sequence ID
                         seq_col='substrate_sequence', # column that contains protein sequence
                         site_col='site', # column that contains site info, e.g., S140
                         
                        ):
    "Phosphorylate whole sequence based on phosphosites in a dataframe"
    df_seq = df.groupby(id_col).agg({site_col:lambda r: r.unique(),seq_col:'first'}).reset_index()
    df_seq['phosphoseq'] = df_seq.apply(lambda r: phosphorylate_seq(r[seq_col],*r[site_col]),axis=1)
    return df_seq

# %% ../nbs/01_utils.ipynb 39
def extract_site_seq(df: pd.DataFrame, # dataframe that contains protein sequence
                     seq_col: str, # column name of protein sequence
                     site_col: str, # column name of site information (e.g., S10)
                     n=7, # length of surrounding sequence (default -7 to +7)
                    ):
    "Extract -n to +n site sequence from protein sequence"
    
    data = []
    for i, r in tqdm(df.iterrows(),total=len(df)):
        position = int(r[site_col][1:]) - 1
        start = position - n
        end = position + n +1

        # Extract the subsequence
        subseq = r[seq_col][max(0, start):min(len(r[seq_col]), end)]

        # Pad the subsequence if needed
        if start < 0:
            subseq = "_" * abs(start) + subseq
        if end > len(r[seq_col]):
            subseq = subseq + "_" * (end - len(r[seq_col]))

        data.append(subseq)
        
    return np.array(data)

# %% ../nbs/01_utils.ipynb 44
def get_reactome_raw(gene_list):
    "Reactome pathway analysis for a given gene set; returns raw output in dataframe."
    gene_str = ','.join(gene_list)
    # set page size and page to -1 ensures to display all pathway results, sort by pvalue instead of fdr, projection set to True is consistent with official web
    result = analysis.identifiers(gene_str, page_size='-1', page='-1', sort_by='ENTITIES_PVALUE',projection=True)
    return json_normalize(result['pathways'])

# %% ../nbs/01_utils.ipynb 47
def get_reactome(gene_list):
    "Reactome pathway analysis for a given gene set; returns formated output in dataframe with additional -log10(p)"
    out = get_reactome_raw(gene_list)
    out = out[['name','entities.pValue']].rename(columns={'entities.pValue':'pValue'})
    out['-log10_pValue'] = -np.log10(out['pValue']).round(3)
    return out

# %% ../nbs/01_utils.ipynb 50
def plot_path(react_out, top_n=10,max_label_length=80):
    "Plot the bar graph of pathways from get_reactome function."
    
    # Extract the data and reverse it
    data = react_out.head(top_n).set_index('name')['-log10_pValue'].iloc[::-1]
    
    # Truncate labels if they are too long
    truncated_labels = [label[:max_label_length] + '...' if len(label) > max_label_length else label for label in data.index]
    data.index = truncated_labels

    # Calculate the required width: base width + additional width for the longest label
    base_width = 2
    max_label_length = max(data.index, key=len)
    additional_width = len(max_label_length) * 0.1  # Adjust scaling factor as needed
    
    figsize = (base_width + additional_width, 3*top_n/10)  # Adjust height as necessary

    data.plot.barh(figsize=figsize)
    plt.ylabel('')
    plt.xlabel('-log10(p)')
    plt.tight_layout()
