# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04b_hierarchical.ipynb.

# %% auto 0
__all__ = ['get_Z_custom', 'get_Z', 'auto_thr', 'get_color_groups', 'get_cluster']

# %% ../nbs/04b_hierarchical.ipynb 2
import pandas as pd,numpy as np
from .data import *
from .pssm.core import recover_pssm
from .pssm.compare import js_divergence_flat
from scipy.cluster.hierarchy import fcluster,linkage,dendrogram
from scipy.spatial.distance import pdist
from matplotlib import pyplot as plt
from cachetools import LRUCache

# %% ../nbs/04b_hierarchical.ipynb 3
def get_Z_custom(df, # Rows=items, cols=features
          metric:str="euclidean", # Distance metric for `pdist`
          method:str|None=None, # Linkage method (auto-chosen if None)
          metric_fn=None, # Custom distance fn (e.g. JS divergence)
         ):
    "Compute hierarchical clustering linkage matrix `Z`."

    X = df.to_numpy(dtype=float)
    method = method or ("ward" if metric=="euclidean" and metric_fn is None else "average")

    if method=="ward":
        if metric!="euclidean" or metric_fn is not None:
            raise ValueError("Ward linkage requires Euclidean distance.")
        return linkage(X, method="ward")

    d = pdist(X, metric=metric_fn or metric)
    return linkage(d, method=method)

# %% ../nbs/04b_hierarchical.ipynb 4
_Z_CACHE = LRUCache(maxsize=50)

# %% ../nbs/04b_hierarchical.ipynb 5
def get_Z(df):
    """Return cached linkage matrix for a dataframe."""
    key = id(df)

    if key not in _Z_CACHE:
        X = df.to_numpy(dtype=float)
        _Z_CACHE[key] = linkage(X, method="ward")

    return _Z_CACHE[key]

# %% ../nbs/04b_hierarchical.ipynb 8
def auto_thr(Z, # Linkage matrix
            percentile=95, # Only consider merge-distance jumps above this percentile.- 90–95: fewer clusters (earlier cut)- 97–99: more clusters (later cut)
            ):
    """
    Pick color threshold at a large jump in linkage distances.
    """
    d = Z[:, 2]
    jumps = np.diff(d)

    # threshold jumps to ignore small/noisy merges
    jump_cutoff = np.percentile(jumps, percentile)

    # candidate indices with large jumps
    candidates = np.where(jumps >= jump_cutoff)[0]
    # fallback: global max jump
    idx = candidates[0] if len(candidates) > 0 else np.argmax(jumps)
    # idx = candidates[-1] if len(candidates) > 0 else np.argmax(jumps)
    
    return d[idx]

# %% ../nbs/04b_hierarchical.ipynb 12
def get_color_groups(Z,  # Linkage matrix
                     thr:float=0.07 # Same threshold as `dendrogram(color_threshold=...)`
                    ):
    "Assign dendrogram color/cluster group IDs."
    return fcluster(Z, thr, criterion='distance')

# %% ../nbs/04b_hierarchical.ipynb 14
def get_cluster(df,pct=95,plot=False):
    "Get flat cluster assignments from hierarchical clustering linkage matrix `Z`."
    Z = get_Z(df)
    thr = auto_thr(Z,percentile=pct)
    clusters = fcluster(Z, thr, criterion='distance')
    if plot: plot_dendrogram(Z,labels=df.index,thr=thr)
    return pd.Series(clusters, index=df.index)
