# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_plot.ipynb.

# %% auto 0
__all__ = ['reduce_dim', 'plot_cluster', 'plot_bar', 'plot_corr', 'kinase_report']

# %% ../nbs/02_plot.ipynb 3
from .feature import *
from .core import Data
from fastbook import *
import seaborn as sns
from scipy.stats import spearmanr, pearsonr

from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from umap.umap_ import UMAP
import joblib
from adjustText import adjust_text
from pathlib import Path

# %% ../nbs/02_plot.ipynb 4
sns.set(rc={"figure.dpi":300, 'savefig.dpi':300})
sns.set_context('notebook')
sns.set_style("ticks")

# %% ../nbs/02_plot.ipynb 5
def reduce_dim(df, 
               method='pca', 
               n_components=2, 
               complexity = 20, # umap default: 15, tsne default: 30
               load=None, # load a previous model
               save=None, # pkl file to be saved, e.g. pca_model.pkl
               seed =123):
    
    "Reduce dim except first column"
    if load is not None:
        reducer = joblib.load(load)
    else:
        if method == 'pca':
            reducer = PCA(n_components=n_components, random_state=seed)
        elif method == 'tsne':
            reducer = TSNE(n_components=n_components,
                           random_state=seed, 
                           perplexity = complexity # default from official is 30 
                          )
        elif method == 'umap':
            reducer = UMAP(n_components=n_components, 
                           random_state=seed, 
                           n_neighbors=complexity # default from official is 15, try 15-200
                          )
        else:
            raise ValueError('Invalid method specified')

    proj = reducer.fit_transform(df.iloc[:, 1:].values)
    embedding_df = pd.DataFrame(proj, columns=[f"{method.upper()}{i}" for i in range(1, n_components + 1)])
    embedding_df = pd.concat([df[df.columns[0]], embedding_df], axis=1)

    if save is not None:
        path = Path(save)
        path.parent.mkdir(exist_ok=True)
        
        joblib.dump(reducer, save)

    return embedding_df

# %% ../nbs/02_plot.ipynb 6
def plot_cluster(df, 
                 method='pca', 
                 hue=None,
                 complexity = 30,
                 palette='tab20', 
                 legend=False, 
                 name_list=None, # a list or df Series of names that label the dots
                 seed = 123
                ):
    embedding_df = reduce_dim(df, method=method, seed=seed, complexity = complexity)
    x_col, y_col = [col for col in embedding_df.columns if col.startswith(method.upper())]
    sns.relplot(data=embedding_df, x=x_col, y=y_col, hue=hue, palette=palette, s=50, alpha=0.8, legend=legend)
    plt.xticks([])
    plt.yticks([])
    if name_list is not None:
        texts = [plt.text(embedding_df[f'{method.upper()}1'][i], embedding_df[f'{method.upper()}2'][i], name_list[i],fontsize=8) for i in range(len(embedding_df))]
        adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black'))
    plt.show()
    plt.close()

# %% ../nbs/02_plot.ipynb 15
def plot_bar(data, 
             value_col, # colname of values
             groupby_col, # colname of categories which is used to groupby values
             circle = True,
             aspect = 3 # the biger, the wider
              ):
    
    order = data.groupby(groupby_col)[value_col].mean().sort_values(ascending=False).index
    g = sns.catplot(data=data,
                x=groupby_col,
                y=value_col,
                aspect=aspect,
                order=order,
                kind='bar',
                ci='sd',
                palette='tab20',)
    g.set_xticklabels(rotation=45)
    
    if circle:
        marker = {'marker': 'o', 
                  'color': 'white', 
                  'edgecolor': 'black', 
                  'linewidth': 1.5, 
                  's': 6}

        sns.stripplot(data=data, 
                      x=groupby_col, 
                      y=value_col,
                      order=order,
                      alpha=0.8,
                      ax=g.ax,
                      **marker);

# %% ../nbs/02_plot.ipynb 18
def plot_corr(x,#a column of df
              y,#a column of df
              xlabel=None,# x axis label
              ylabel=None,# y axis label
              order=1, # polynomial level, if straight, order=1
              method = 'pearson'
             ):
    if method == 'spearman':
        correlation, pvalue = spearmanr(x, y)
    elif method == 'pearson':
        correlation, pvalue = pearsonr(x, y)
    else:
        raise ValueError("Invalid correlation method. Choose 'spearman' or 'pearson'.")
        
    sns.regplot(x=x,
            y=y,
            order=order,
            line_kws={'color': 'gray'}
           )
    
    if xlabel is not None:
        plt.xlabel(xlabel)
        
    if ylabel is not None:
        plt.ylabel(ylabel)
    
    correlation_text = f'Spearman: {correlation:.2f}' if method == 'spearman' else f'Pearson: {correlation:.2f}'

    plt.text(x=0.8, y=0.1, s=correlation_text, transform=plt.gca().transAxes, ha='center', va='center')
    
    plt.show()
    plt.close()

# %% ../nbs/02_plot.ipynb 23
def kinase_report(pred, kinase):
    
    pred_stack = pred.pivot(values = 'pred',index='kinase',columns = 'substrate').reset_index()

    label_stack = pred.pivot(values = 'label',index='kinase',columns = 'substrate').reset_index()
    
    raw_stack = Data.get_kinase_raw()
    
    print(f'Logo of {kinase}  from raw dataset')
    raw2logo(raw_stack, kinase)

    print(f'Logo of {kinase}  from reversed label')
    raw2logo(label_stack, kinase);

    print(f'Logo of {kinase}  based on prediction')
    raw2logo(pred_stack, kinase)

    
    print('correlation')
    plot_corr(pred.query(f'kinase == "{kinase}"').label,
          pred.query(f'kinase == "{kinase}"').pred, 
          method='pearson')

    
    print('colored by aa')
    sns.relplot(x = pred.query(f'kinase == "{kinase}"').label, 
            y = pred.query(f'kinase == "{kinase}"').pred, 
            hue = pred.query(f'kinase == "{kinase}"').aa, 
            palette = 'tab20' )
    plt.show()
    plt.close()
    
    return pred_stack, label_stack
