# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_plot.ipynb.

# %% auto 0
__all__ = ['logo_func', 'get_logo', 'get_logo2', 'plot_rank', 'get_heatmap', 'plot_heatmap', 'plot_cluster', 'assign_colors',
           'plot_bokeh', 'plot_bokeh_category', 'plot_bar', 'plot_corr', 'draw_corr']

# %% ../nbs/02_plot.ipynb 3
#| output: False
from .feature import *
from .core import *
from fastbook import *
import seaborn as sns
from scipy.stats import spearmanr, pearsonr
import logomaker

import joblib
from adjustText import adjust_text
from pathlib import Path

from bokeh.io import output_notebook, show
from bokeh.plotting import figure, ColumnDataSource
from bokeh.models import HoverTool, AutocompleteInput, CustomJS
from bokeh.layouts import column
from itertools import cycle
from bokeh.palettes import Category20_20
from itertools import cycle

# %% ../nbs/02_plot.ipynb 7
def logo_func(df, 
              title = 'logo'):
    
    aa = {
        'AG': '#037f04',
        'DEsty': '#da143e', # sty essm to be the color as big ST&Y
        'F': '#84380b',
        'HQN': '#8d2be1',
        'LMIFWTVC': '#d9a41c',
        'P': '#000000',
        'RK': '#0000ff',
        'ST': '#8d008d',
        'Y': '#84380b',
        
        # 'st':'#8d2be1',
        # 'y':'#8d2be1'
        # 'pS/pT':'#8d2be1',
        # 'pY':'#8d2be1'
    }
    logo = logomaker.Logo(df,color_scheme = aa,flip_below=False,figsize=(7,2.5)) #5.5,2.5
    
    logo.style_xticks(fmt='%d')
    logo.ax.set_yticks([])
    logo.ax.set_title(title)

# %% ../nbs/02_plot.ipynb 8
def get_logo(df, # Stacked Dataframe with kinase as index, substrates as columns
             kinase, # A specific kinase name in index
               ):
    "Given stacked df (index as kinase, columns as substrates), get specific kinase's logo"
    
    
    #get raw kinase to calculate S/T
    pp = get_one_kinase(df,kinase,normalize=False)
    
    #get S/T ratio value
    ss = pp['S'].sum()
    st = pp['T'].sum()

    S_ctrl = 0.75*ss - 0.25*st
    T_ctrl = 0.75*st - 0.25*ss

    S0 = S_ctrl / max(S_ctrl, T_ctrl)
    T0 = T_ctrl / max(S_ctrl, T_ctrl)

    S_ratio = S0/(S0+T0)
    T_ratio = T0/(S0+T0)
    
    #get normalized kinase
    norm_p = get_one_kinase(df,kinase, normalize=True)
    
    ratio =norm_p.apply(lambda r: r/r.median(),axis=1)

    ratio = np.log2(ratio)

    m = ratio.apply(lambda row: row[row > 0].sum(), axis=1).max()

    new_row = pd.DataFrame({'S': S_ratio*m, 'T':T_ratio*m}, index=[0]) 

    ratio2 = pd.concat([ratio, new_row], ignore_index=False).fillna(0)
    
    #plot logo
    logo_func(ratio2, kinase)

# %% ../nbs/02_plot.ipynb 9
def get_logo2(full, title):
    S_ratio,T_ratio,Y_ratio = full[0][['s','t','y']]/full[0][['s','t','y']].sum()

    full = full.drop(columns=[0])
    
    # Identify the minimum value other than 0
    min_val = full[full > 0].min().min()
    # Replace 0s with the identified minimum value
    full = full.replace(0, min_val)

    norm_p = full.T

    ratio =norm_p.apply(lambda r: r-r.median(),axis=1)
#     ratio =norm_p.apply(lambda r: r/r.median(),axis=1)

#     ratio = np.log2(ratio)

    m = ratio.apply(lambda row: row[row > 0].sum(), axis=1).max()

    new_row = pd.DataFrame({'S': S_ratio*m, 'T':T_ratio*m,'Y':Y_ratio*m}, index=[0]) 

    ratio2 = pd.concat([ratio, new_row], ignore_index=False).fillna(0)

    logo_func(ratio2,title)

# %% ../nbs/02_plot.ipynb 14
def plot_rank(sorted_df, x, y, n_hi=10,n_lo=10,figsize=(10,8),**kwargs):

    plt.figure(figsize=figsize)
    sorted_df = sorted_df.reset_index(drop=True)
    sns_plot = sns.scatterplot(data=sorted_df, 
                               x = x,
                               y = y, **kwargs)

    sns_plot.set_xticks([])
    
    
    texts = []
    
    # Annotate the highest n values
    if n_hi is not None:
        
        for i, row in sorted_df.head(n_hi).iterrows():
            texts.append(plt.text(i, row[y], row[x], ha='center', va='bottom'))

    if n_lo is not None:
        # Annotate the lowest n values
        n_lowest = n_lo
        for i, row in sorted_df.tail(n_lowest).iterrows():
            texts.append(plt.text(i, row[y], row[x], ha='center', va='bottom'))
            
    if len(texts)>0:
        # Use adjustText to adjust text positions
        adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black'))

    plt.tight_layout()

# %% ../nbs/02_plot.ipynb 16
def get_heatmap(df, # Stacked Dataframe with kinase as index, substrates as columns
                kinase # A specific kinase name in index
               ):
    aa_order = [i for i in 'PGACSTVILMFYWHKRQNDEty']
    # position_order = [str(i) for i in range(-5,5)]
    # position_order.remove('0')
    
    kk = get_one_kinase(df, kinase).T
    # kkk = kk.reindex(index=aa_order, columns=position_order)
    kkk = kk.reindex(index=aa_order)
    
    plt.figure(figsize=(6, 10))
    sns.heatmap(kkk, cmap='binary', annot=False)
    plt.title(kinase)

# %% ../nbs/02_plot.ipynb 17
def plot_heatmap(matrix,title,figsize=(6,10)):
    
    plt.figure(figsize=figsize)
    sns.heatmap(matrix, cmap='binary', annot=False)
    plt.title(title)

# %% ../nbs/02_plot.ipynb 21
def plot_cluster(df, # a dataframe with values, and index as identity
                 method='pca', # Could be 'tsne', 'umap'
                 hue=None,
                 complexity = 30, # 30 for tsne, 15 for umap, none for pca
                 palette='tab20', # could be tab10 if less categories
                 legend=False, 
                 name_list=None, # if not none, will annotate each dots in the plot
                 seed = 123, 
                  s = 50,
                  **kwargs
                ):
    
    "Given a dataframe of values, plot it in 2d, method could be pca, tsne, or umap"
    
    embedding_df = reduce_feature(df, method=method, seed=seed, complexity = complexity,**kwargs)
    # x_col, y_col = [col for col in embedding_df.columns if col.startswith(method.upper())]
    x_col, y_col = embedding_df.columns
    sns.relplot(data=embedding_df, x=x_col, y=y_col, hue=hue, palette=palette, s=s, alpha=0.8, legend=legend)
    plt.xticks([])
    plt.yticks([])
    if name_list is not None:
        texts = [plt.text(embedding_df[x_col][i], embedding_df[y_col][i], name_list[i],fontsize=8) for i in range(len(embedding_df))]
        adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black'))

# %% ../nbs/02_plot.ipynb 26
def assign_colors(categories, palette):
    "assign colors to category in a dataframe, returns the same length of df"
    color_cycle = cycle(palette)
    color_map = {category: next(color_cycle) for category in categories}
    return [color_map[category] for category in categories]

# %% ../nbs/02_plot.ipynb 27
def plot_bokeh(X, 
               idx:list, # identities for searching box & autocompletion
               colors=None,
               s=3, **kwargs):
    
    output_notebook()
    if colors is not None:
        colors  = colors
    else:
        colors = ['navy'] * len(X)
        
    
    data_dict={
    'x': X.iloc[:,0],
    'y': X.iloc[:,1],
    'identity': idx,
    'color': colors,
    'original_color': colors,
    'size': [s] * len(X), 
    'highlighted': ['no'] * len(X)  # To keep track of which dot is highlighted
    }
    
    for key, value in kwargs.items():
        data_dict[key] = value
    
    source = ColumnDataSource(data=data_dict)
    
    p = figure(tools="pan,box_zoom,wheel_zoom,reset")
    p.scatter('x', 'y', source=source, alpha=0.6, color='color', size='size')

    # Disable grid lines
    p.xgrid.visible = False
    p.ygrid.visible = False
    
    # Add hover tool
    hover = HoverTool()
    
    tooltips = [("Identity", "@identity")]

    for key in kwargs.keys():
        tooltips.append((key.capitalize(), f"@{key}"))

    
    hover.tooltips = tooltips
    p.add_tools(hover)
    
    
    autocomplete = AutocompleteInput(title="Search by Identity:", completions=idx)

    callback = CustomJS(args=dict(source=source, plot=p), code="""
        const data = source.data;
        const search_val = cb_obj.value.toLowerCase();
        const x = data['x'];
        const y = data['y'];
        const identity = data['identity'];
        const color = data['color'];
        const original_color = data['original_color'];
        const size = data['size'];
        const highlighted = data['highlighted'];

        for (let i = 0; i < identity.length; i++) {
            if (highlighted[i] === 'yes') {
                color[i] = original_color[i];
                size[i] = 10;
                highlighted[i] = 'no';
            }
            if (identity[i].toLowerCase() === search_val) {
                plot.x_range.start = x[i] - 5;
                plot.x_range.end = x[i] + 5;
                plot.y_range.start = y[i] - 5;
                plot.y_range.end = y[i] + 5;
                color[i] = 'red';
                size[i] = 15;
                highlighted[i] = 'yes';
            }
        }
        source.change.emit();
    """)
    autocomplete.js_on_change('value', callback)

    # Show layout
    layout = column(autocomplete, p)
    show(layout)

# %% ../nbs/02_plot.ipynb 28
def plot_bokeh_category(X, 
               idx:list, # identities for searching box
               cat=None, # categories to color
               s=3, **kwargs):
        
    output_notebook()
    if cat is not None:
        colors  = assign_colors(cat, Category20_20)
    else:
        colors = ['navy'] * len(X)
        
    
    data_dict={
    'x': X.iloc[:,0],
    'y': X.iloc[:,1],
    'identity': idx,
    'color': colors,
    'original_color': colors,
    'size': [s] * len(X), 
    'highlighted': ['no'] * len(X)  # To keep track of which dot is highlighted
    }
    
    for key, value in kwargs.items():
        data_dict[key] = value
    
    source = ColumnDataSource(data=data_dict)
    
    p = figure(tools="pan,box_zoom,wheel_zoom,reset")
    p.scatter('x', 'y', source=source, alpha=0.6, color='color', size='size')

    # Disable grid lines
    p.xgrid.visible = False
    p.ygrid.visible = False
    
    # Add hover tool
    hover = HoverTool()
    
    tooltips = [("Identity", "@identity")]

    for key in kwargs.keys():
        tooltips.append((key.capitalize(), f"@{key}"))

    
    hover.tooltips = tooltips
    p.add_tools(hover)
    
    
    autocomplete = AutocompleteInput(title="Search by Identity:", completions=idx)

    callback = CustomJS(args=dict(source=source, plot=p), code="""
        const data = source.data;
        const search_val = cb_obj.value.toLowerCase();
        const x = data['x'];
        const y = data['y'];
        const identity = data['identity'];
        const color = data['color'];
        const original_color = data['original_color'];
        const size = data['size'];
        const highlighted = data['highlighted'];

        for (let i = 0; i < identity.length; i++) {
            if (highlighted[i] === 'yes') {
                color[i] = original_color[i];
                size[i] = 10;
                highlighted[i] = 'no';
            }
            if (identity[i].toLowerCase() === search_val) {
                plot.x_range.start = x[i] - 5;
                plot.x_range.end = x[i] + 5;
                plot.y_range.start = y[i] - 5;
                plot.y_range.end = y[i] + 5;
                color[i] = 'red';
                size[i] = 15;
                highlighted[i] = 'yes';
            }
        }
        source.change.emit();
    """)
    autocomplete.js_on_change('value', callback)

    # Show layout
    layout = column(autocomplete, p)
    show(layout)

# %% ../nbs/02_plot.ipynb 33
def plot_bar(df, # dataframe with a column of values, and a column of category to groupby
             values, # colname of values
             category, # colname of categories which is used to groupby values
             circle = True, # whether or not add dots in the graph
             aspect = 3, # the biger the value is, the wider the graph is
             rotation=45,
             **kwargs
              ):
    
    order = df.groupby(category)[values].mean().sort_values(ascending=False).index
    g = sns.catplot(data=df,
                x=category,
                y=values,
                aspect=aspect,
                order=order,
                kind='bar',
                ci='sd',
                **kwargs)
    g.set_xticklabels(rotation=rotation)
    
    if circle:
        marker = {'marker': 'o', 
                  'color': 'white', 
                  'edgecolor': 'black', 
                  'linewidth': 1.5, 
                  's': 6}

        sns.stripplot(data=df, 
                      x=category, 
                      y=values,
                      order=order,
                      alpha=0.8,
                      ax=g.ax,
                      **marker);

# %% ../nbs/02_plot.ipynb 38
def plot_corr(
              x,
              y,
              xlabel=None,# x axis label
              ylabel=None,# y axis label
            data = None,
            text_location = [0.8,0.1],
            **kwargs
             ):
    "Given a dataframe and the name of two columns, plot the two columns' correlation"
    if data is not None:
        x=data[x]
        y=data[y]
        
    pear, pvalue = pearsonr(x, y)
        
    sns.regplot(
                x=x,
                y=y,
                line_kws={'color': 'gray'}, **kwargs
           )
    
    if xlabel is not None:
        plt.xlabel(xlabel)
        
    if ylabel is not None:
        plt.ylabel(ylabel)
    
    # correlation_text = f'Spearman: {correlation:.2f}' if method == 'spearman' else f'Pearson: {correlation:.2f}'

    # plt.text(x=0.8, y=0.1, s=correlation_text, transform=plt.gca().transAxes, ha='center', va='center')
    plt.text(s=f'Pearson = {round(pear,2)}\n   p = {"{:.2e}".format(pvalue)}',
             x=text_location[0],y=text_location[1],
            transform=plt.gca().transAxes, 
             ha='center', va='center')

# %% ../nbs/02_plot.ipynb 44
def draw_corr(corr):
    # Mask for the upper triangle
    mask = np.triu(np.ones_like(corr, dtype=bool))
    
    # Plotting the heatmap
    plt.figure(figsize=(20, 16))  # Set the figure size
    sns.heatmap(corr, annot=True, cmap='coolwarm', vmin=-1, vmax=1, mask=mask, fmt='.2f')
    plt.title("Correlation heatmap between amino acids")
